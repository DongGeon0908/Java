package ex12_more;
/*   
 * [ BitCount2_ClearSameStmts ]: 양의 정수를 입력하여 그 정수의 1인 비트 개수 구하기
 *   
 *   o 프로그래밍 스타일 
 *     1) main() 메소드로만 클래스 구성
 *     2) 반복문 사용하지 않기
 *        - 입력된 정수와 1비트만 1인 양의 정수 31개(1, 2, 4, 8, 16, ...)에 대해 
 *          비트별 AND를 31번 수행하여 1인 비트의 개수를 구함
 *        - 반복되는 유사한 문장들의 변화양상을 명확히 표현 
 *        - 유사한 문장들을 동일한 문장들로 표현
 *   
 *      o 1인 비트수를 구하는 방법:
 *        - 특정 위치의 비트만 1인 정수와 bit-wise & (bit-wise AND) 연산을 수행하여 
 *          결과가 0이 아니면 그 위치의 비트값은 1임
 *        
 *        - 이를 이용하여 입력된 정수와 특정 위치의 비트만 1인 정수 31개를 & 연산을 
 *          수행하여 1인 bit의 개수를 구할 수 있음  
 *        
 *        - 1은 가장 오른쪽 비트가 1인 수이다. 1을 (i - 1) 비트 왼쪽 쉬프트시키면 오른쪽에서
 *          i번째 비트만 1인 수이므로 이를 이용하여 1비트만 1인 수를 구함
 */

class Ex4_07_6_BitCount2_ClearSameStmts  {
	public static void main(String[] args)  {
		int n;         // 입력된 값을 저장할 변수
		
		System.out.println("\n\n   ****  Getting count of 1 bits of an integer ****");

		System.out.print("\n  o Enter a number less than or equal to "+ 0x7FFF_FFFF + " > ");  // 0x7FFF_FFFF는 int 타입 값 중에서 최고값
		n = SkScanner.getInt();

		int cnt = 0;   // 1인 비트의 개수를 저장할 변수

		int i = 0;  // 유사한 문장들을 동일한 문장들로 통합하기 위한 수단인 변수 ==> for 문에서의 반복 제어변수
		
		if ((n & (1 << i)) != 0) cnt++;  i++;    // (n & (1 << i)가 0이 아니면 오른쪽 1번째 비트가 1이므로 cnt 1 증가
		if ((n & (1 << i)) != 0) cnt++;  i++;    // (n & (1 << i)가 0이 아니면 오른쪽 2번째 비트가 1이므로 cnt 1 증가
		if ((n & (1 << i)) != 0) cnt++;  i++;    // (n & (1 << i)가 0이 아니면 오른쪽 3번째 비트가 1이므로 cnt 1 증가
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;

		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;

		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;

		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;

		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		if ((n & (1 << i)) != 0) cnt++;  i++;
		
		if ((n & (1 << i)) != 0) cnt++;  i++;  // (n & (1 << i)가 0이 아니면 왼쪽 2번째 비트가 1이므로 cnt 1 증가		
                                               // 왼쪽 1번째 비트는 부호 비트이므로 양의 정수인 경우 항상 0임
		
		System.out.println("\n  * Count of 1 bits of " + n + " is " + cnt);

		main(args);   // 이는 가장 쉽게 전체를 반복시키는 방법임
	}
}

/*
 *  [ 실습 과제 ]
 *  
 *    1) 이 방법은 변수 i를 이용하여 i 번째 비트만 1인 정수를 (1 << i)로 표현하므로 
 *       31개의 if 문장들이 완전히 동일한 문장으로 표현된다. 
 *       
 *       이러한 동일한 문장들의 반복은 for 문을 이용한 프로그램으로 쉽게 바꿀 수 있다. 
 *       이 프로그램을 for 문을 사용한 프로그램으로 변경하라.
 *      
 *    2) 본인이 작성한 프로그램과 실습자료의 Ex4_7_7_BitCount2_UsingFor.java를 비교하여 보라.
 *      
 *      
 *  [ 스스로 생각하고 고민해볼 과제 ]
 *  
 *    o 반복문을 제대로 이해하려면 반복문으로 작성하지 않은 스타일의 프로그램도 많이 작성해야 한다. 
 *      반복문을 사용하지 않는 프로그램 작성연습은 이전 실습과정에서 많이 이루어졌으며, 
 *      지금 단계에서 다시 한번 해보면 반복문과 관련하여 많은 도움이 된다.
 *      
 *      다시 한번 처음부터 반복문을 사용하지 않는 프로그램의 작성을 복습하기를 바란다.
 */