package ex12_more;
/*   
 * [ BitCount2_Clear ]: 양의 정수를 입력하여 그 정수의 1인 비트 개수 구하기
 *   
 *   o 프로그래밍 스타일 
 *     1) main() 메소드로만 클래스 구성
 *     2) 반복문 사용하지 않기
 *        - 입력된 정수와 1비트만 1인 양의 정수 31개(1, 2, 4, 8, 16, ...)에 대해 
 *          비트별 AND를 31번 수행하여 1인 비트의 개수를 구함
 *        - 반복되는 유사한 문장들의 변화양상을 명확히 표현하기 위해 1, 2, 4, 8 등을 
 *          1 << 0, 1 << 1, 1 << 2, 1 << 3 으로 표현함 
 *   
 *   o 1인 비트수를 구하는 방법:
 *     - 특정 위치의 비트만 1인 정수와 bit-wise & (bit-wise AND) 연산을 수행하여 
 *       결과가 0이 아니면 그 위치의 비트값은 1임
 *        
 *     - 이를 이용하여 입력된 정수와 특정 위치의 비트만 1인 정수 31개를 & 연산을 
 *       수행하여 1인 bit의 개수를 구할 수 있음  
 *        
 *     - 1은 가장 오른쪽 비트가 1인 수이다. 1을 (i - 1) 비트 왼쪽 쉬프트시키면 오른쪽에서
 *       i번째 비트만 1인 수이므로 이를 이용하여 1비트만 1인 수를 구함
 */

class Ex4_9_8_BitCount3  {
	public static void main(String[] args)  {
		int n;         // 입력된 값을 저장할 변수
		
		System.out.println("\n\n   ****  Getting count of 1 bits of an integer ****");

		System.out.print("\n  o Enter a number less than or equal to "+ 0x7FFF_FFFF + " > ");  // 0x7FFF_FFFF는 int 타입 값 중에서 최고값
		n = SkScanner.getInt();

		int cnt = 0;   // 1인 비트의 개수를 저장할 변수

		if ((n & (1 << 0) ) != 0) cnt++;      // (n & (1 << 0)이 0이 아니면 오른쪽 1번째 비트가 1이므로 cnt 1 증가
		if ((n & (1 << 1) ) != 0) cnt++;      // (n & (1 << 1)이 0이 아니면 오른쪽 2번째 비트가 1이므로 cnt 1 증가
		if ((n & (1 << 2)) != 0) cnt++;       // (n & (1 << 2)가 0이 아니면 오른쪽 3번째 비트가 1이므로 cnt 1 증가
		if ((n & (1 << 3)) != 0) cnt++;
		if ((n & (1 << 4)) != 0) cnt++;

		if ((n & (1 << 5)) != 0) cnt++;
		if ((n & (1 << 6)) != 0) cnt++;
		if ((n & (1 << 7)) != 0) cnt++;
		if ((n & (1 << 8)) != 0) cnt++;
		if ((n & (1 << 9)) != 0) cnt++;

		if ((n & (1 << 10)) != 0) cnt++;
		if ((n & (1 << 11)) != 0) cnt++;
		if ((n & (1 << 12)) != 0) cnt++;
		if ((n & (1 << 13)) != 0) cnt++;
		if ((n & (1 << 14)) != 0) cnt++;

		if ((n & (1 << 15)) != 0) cnt++;
		if ((n & (1 << 16)) != 0) cnt++;
		if ((n & (1 << 17)) != 0) cnt++;
		if ((n & (1 << 18)) != 0) cnt++;
		if ((n & (1 << 19)) != 0) cnt++;

		if ((n & (1 << 20)) != 0) cnt++;
		if ((n & (1 << 21)) != 0) cnt++;
		if ((n & (1 << 22)) != 0) cnt++;
		if ((n & (1 << 23)) != 0) cnt++;
		if ((n & (1 << 24)) != 0) cnt++;
		
		if ((n & (1 << 25)) != 0) cnt++;
		if ((n & (1 << 26)) != 0) cnt++;
		if ((n & (1 << 27)) != 0) cnt++;
		if ((n & (1 << 28)) != 0) cnt++;
		if ((n & (1 << 29)) != 0) cnt++;
		
		if ((n & (1 << 30)) != 0) cnt++;  // (n & (1 << 30)가 0이 아니면 왼쪽 2번째 비트가 1이므로 cnt 1 증가		
                                          // 왼쪽 1번째 비트는 부호 비트이므로 양의 정수인 경우 항상 0임
		
		System.out.println("\n  * Count of 1 bits of " + n + " is " + cnt);

		main(args);   // 이는 가장 쉽게 전체를 반복시키는 방법임
	}
}

/*
 *  [ 실습 과제 ]
 *  
 *    1) 이 프로그램에서는 x-1 번째 비트만 1인 정수를 (1 << x)로 표현하고, x가 0부터 30까지 차례로 
 *       변화하므로 31개의 유사한 if 문장들의 변화양상을 쉽게 파악할 수 있으며, 
 *       이를 통하여 for 문을 이용한 프로그램으로 쉽게 바꿀 수 있다. 
 *       
 *       for 문장을 이용한 프로그램으로 변경하기 전에 이 프로그램의 유사한 if 문장들을 
 *       완전히 동일한 문장들로 변경하라. 이 때에는 다른 변수를 사용하여야 한다. 
 *      
 *    2) 이 프로그램을 for 문장을 이용한 프로그램으로 변경하고, 
 *       본인이 작성한 프로그램과 실습자료의 Ex4_7_7_BitCount2_UsingFor.java를 비교하여 보라.
 *      
 *      
 *  [ 스스로 생각하고 고민해볼 과제 ]
 *  
 *    o 반복문을 제대로 이해하려면 반복문으로 작성하지 않은 스타일의 프로그램도 많이 
 *      작성해야 한다. 이미 이러한 반복문 미사용 작성연습은 실습과정에서 많이 이루어졌으며, 
 *      다시 한번 처음부터 복습하기를 바란다.
 */